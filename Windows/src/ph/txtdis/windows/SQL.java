package ph.txtdis.windows;


public class SQL {
	public final static boolean NO_CUTOFF_DATES = false;
	public final static boolean WITH_CUTOFF_DATES = true;
	public final static boolean NO_ROUTES = false;
	public final static boolean PER_ROUTE = true;
	public final static int NO_REFERENCE = 0;

	public static String addCreditTermStmt() {
		return  // @sql:on
				"        latest_credit_term_date\n"
		        + "        AS (  SELECT customer_id, max (start_date) AS start_date\n"
		        + "                FROM credit_detail\n" 
		        + "            GROUP BY customer_id),\n"
		        + "        latest_credit_term\n" 
		        + "        AS (SELECT cd.customer_id, cd.term\n"
		        + "              FROM credit_detail AS cd\n"
		        + "                   INNER JOIN latest_credit_term_date AS lctd\n"
		        + "                      ON     cd.customer_id = lctd.customer_id\n"
		        + "                         AND cd.start_date = lctd.start_date)"
		        // @sql:off
		        ;
	}

	public static String addRouteLatestStmt() {
		return  // @sql:on
				"        latest_route_date\n"
		        + "        AS (  SELECT customer_id, max (start_date) AS start_date\n"
		        + "                FROM account\n" 
		        + "            GROUP BY customer_id),\n"
		        + "        latest_route\n" 
		        + "        AS (SELECT cd.customer_id, cd.route_id\n"
		        + "              FROM account AS cd\n"
		        + "                   INNER JOIN latest_route_date AS lctd\n"
		        + "                      ON     cd.customer_id = lctd.customer_id\n"
		        + "                         AND cd.start_date = lctd.start_date)"
		        // @sql:off
		        ;
	}

	public static String addItemParentStmt() {
		return  // @sql:on
				"WITH RECURSIVE parent_child (child_id, parent_id) " 
				+ "AS ( " 
				+ " SELECT it.child_id, "
		        + "        it.parent_id " 
				+ "   FROM item_tree AS it " 
		        + "  UNION ALL "
		        + " SELECT parent_child.child_id, " 
		        + "        it.parent_id " 
		        + "   FROM item_tree it "
		        + "   JOIN parent_child " 
		        + "     ON it.child_id = parent_child.parent_id " 
		        + " ) "
		        // @sql:off
		        ;
	}

	public static String addPaymentStmt() {
		return  // @sql:on
				"  payment AS ( " 
				+ "      SELECT rd.order_id, " 
				+ "             rd.series, "
				+ "             max (rd.remit_id) as remit_id, "
		        + "             sum (CASE WHEN rd.payment IS NULL THEN 0 ELSE rd.payment END) AS payment "
		        + "        FROM remittance_detail AS rd\n"
		        + "             INNER JOIN remittance_header AS rh\n"
		        + "                ON rh.remit_id = rd.remit_id\n"
		        + "       WHERE remit_date <= current_date\n"
		        + "    GROUP BY order_id, " 
		        + "             series "
		        + ") "
		        // @sql:off
		        ;
	}

	public static String addInventoryStmt() {
		return  ""
				// @sql:on
				+ "        last_count AS (SELECT max (count_date) AS count_date FROM count_closure),\n" 
				+ "        stock_take\n" 
				+ "        AS (  SELECT id.item_id, qc_id, sum (id.qty * qp.qty) AS qty\n" 
				+ "                FROM count_header AS ih\n" 
				+ "                     INNER JOIN count_detail AS id ON ih.count_id = id.count_id\n" 
				+ "                     INNER JOIN qty_per AS qp ON id.uom = qp.uom AND id.item_id = qp.item_id\n" 
				+ "                     INNER JOIN last_count ON ih.count_date = last_count.count_date\n" 
				+ "                     INNER JOIN item_master AS im ON id.item_id = im.id\n" 
				+ "            GROUP BY id.item_id, qc_id),\n" 
				+ "        adjustment\n" 
				+ "        AS (SELECT item_id, qc_id, qty\n" 
				+ "              FROM count_adjustment AS ca INNER JOIN last_count AS lc ON ca.count_date = lc.count_date),\n" 
				+ "        adjusted\n" 
				+ "        AS (SELECT * FROM stock_take\n" 
				+ "            UNION\n" 
				+ "            SELECT * FROM adjustment),\n" 
				+ "        beginning\n" 
				+ "        AS (  SELECT item_id, qc_id, sum (qty) AS qty\n" 
				+ "                FROM adjusted\n" 
				+ "            GROUP BY item_id, qc_id),\n" 
				+ "        brought_in\n" 
				+ "        AS (  SELECT id.item_id, qc_id, sum (id.qty * qp.qty) AS qty\n" 
				+ "                FROM receiving_header AS ih\n" 
				+ "                     INNER JOIN receiving_detail AS id ON ih.receiving_id = id.receiving_id\n" 
				+ "                     INNER JOIN qty_per AS qp ON id.uom = qp.uom AND id.item_id = qp.item_id\n" 
				+ "                     INNER JOIN last_count AS lc\n" 
				+ "                        ON ih.receiving_date BETWEEN lc.count_date + 1 AND current_date\n" 
				+ "            GROUP BY id.item_id, qc_id),\n" 
				+ "        sold_bundled\n" 
				+ "        AS (  SELECT bom.part_id AS item_id, 0 AS qc_id, sum (id.qty * bom.qty * qp.qty) AS qty\n" 
				+ "                FROM invoice_header AS ih\n" 
				+ "                     INNER JOIN invoice_detail AS id\n" 
				+ "                        ON ih.invoice_id = id.invoice_id AND ih.series = id.series\n" 
				+ "                     INNER JOIN last_count AS lc\n" 
				+ "                        ON ih.invoice_date BETWEEN lc.count_date + 1 AND current_date\n" 
				+ "                     INNER JOIN bom ON id.item_id = bom.item_id\n" 
				+ "                     INNER JOIN qty_per AS qp ON bom.uom = qp.uom AND bom.part_id = qp.item_id\n" 
				+ "                     INNER JOIN item_master AS im ON id.item_id = im.id AND im.type_id = 2\n" 
				+ "            GROUP BY bom.part_id, qc_id),\n" 
				+ "        sold_as_is\n" 
				+ "        AS (  SELECT id.item_id, 0 AS qc_id, sum (id.qty * qp.qty) AS qty\n" 
				+ "                FROM invoice_header AS ih\n" 
				+ "                     INNER JOIN invoice_detail AS id\n" 
				+ "                        ON ih.invoice_id = id.invoice_id AND ih.series = id.series\n" 
				+ "                     INNER JOIN qty_per AS qp ON id.uom = qp.uom AND id.item_id = qp.item_id\n" 
				+ "                     INNER JOIN last_count AS lc\n" 
				+ "                        ON ih.invoice_date BETWEEN lc.count_date + 1 AND current_date\n" 
				+ "                     INNER JOIN item_master AS im ON id.item_id = im.id AND im.type_id <> 2\n" 
				+ "            GROUP BY id.item_id, qc_id),\n" 
				+ "        sold_combined\n" 
				+ "        AS (SELECT * FROM sold_bundled\n" 
				+ "            UNION\n" 
				+ "            SELECT * FROM sold_as_is),\n" 
				+ "        sold\n" 
				+ "        AS (  SELECT item_id, qc_id, sum (qty) AS qty\n" 
				+ "                FROM sold_combined\n" 
				+ "            GROUP BY item_id, qc_id),\n" 
				+ "        delivered_bundled\n" 
				+ "        AS (  SELECT bom.part_id AS item_id,\n" 
				+ "                     CASE WHEN cm.name LIKE '%DISPOSAL%' THEN 2 ELSE 0 END AS qc_id,\n" 
				+ "                     sum (id.qty * bom.qty * qp.qty) AS qty\n" 
				+ "                FROM delivery_header AS ih\n" 
				+ "                     INNER JOIN delivery_detail AS id ON ih.delivery_id = id.delivery_id\n" 
				+ "                     INNER JOIN customer_master AS cm ON ih.customer_id = cm.id\n" 
				+ "                     INNER JOIN last_count AS lc\n" 
				+ "                        ON ih.delivery_date BETWEEN lc.count_date + 1 AND current_date\n" 
				+ "                     INNER JOIN bom ON id.item_id = bom.item_id\n" 
				+ "                     INNER JOIN qty_per AS qp ON bom.uom = qp.uom AND bom.part_id = qp.item_id\n" 
				+ "                     INNER JOIN item_master AS im ON id.item_id = im.id AND im.type_id = 2\n" 
				+ "            GROUP BY bom.part_id, qc_id),\n" 
				+ "        delivered_as_is\n" 
				+ "        AS (  SELECT id.item_id,\n" 
				+ "                     CASE WHEN cm.name LIKE '%DISPOSAL%' THEN 2 ELSE 0 END AS qc_id,\n" 
				+ "                     sum (id.qty * qp.qty) AS qty\n" 
				+ "                FROM delivery_header AS ih\n" 
				+ "                     INNER JOIN delivery_detail AS id ON ih.delivery_id = id.delivery_id\n" 
				+ "                     INNER JOIN customer_master AS cm ON ih.customer_id = cm.id\n" 
				+ "                     INNER JOIN qty_per AS qp ON id.uom = qp.uom AND id.item_id = qp.item_id\n" 
				+ "                     INNER JOIN last_count AS lc\n" 
				+ "                        ON ih.delivery_date BETWEEN lc.count_date + 1 AND current_date\n" 
				+ "                     INNER JOIN item_master AS im ON id.item_id = im.id AND im.type_id <> 2\n" 
				+ "            GROUP BY id.item_id, qc_id),\n" 
				+ "        delivered_combined\n" 
				+ "        AS (SELECT * FROM delivered_bundled\n" 
				+ "            UNION\n" 
				+ "            SELECT * FROM delivered_as_is),\n" 
				+ "        delivered\n" 
				+ "        AS (  SELECT item_id, qc_id, sum (qty) AS qty\n" 
				+ "                FROM delivered_combined\n" 
				+ "            GROUP BY item_id, qc_id),\n" 
				+ "        sent_out_combined\n" 
				+ "        AS (SELECT * FROM sold\n" 
				+ "            UNION\n" 
				+ "            SELECT * FROM delivered),\n" 
				+ "        sent_out\n" 
				+ "        AS (  SELECT item_id, qc_id, sum (qty) AS qty\n" 
				+ "                FROM sent_out_combined\n" 
				+ "            GROUP BY item_id, qc_id),\n" 
				+ "        good\n" 
				+ "        AS (SELECT im.id,\n" 
				+ "                   0 AS qc_id,\n" 
				+ "                     CASE WHEN beginning.qty IS NULL THEN 0 ELSE beginning.qty END\n" 
				+ "                   + CASE WHEN brought_in.qty IS NULL THEN 0 ELSE brought_in.qty END\n" 
				+ "                   - CASE WHEN sent_out.qty IS NULL THEN 0 ELSE sent_out.qty END\n" 
				+ "                      AS ending\n" 
				+ "              FROM item_master AS im\n" 
				+ "                   LEFT JOIN beginning ON im.id = beginning.item_id AND beginning.qc_id = 0\n" 
				+ "                   LEFT JOIN brought_in ON im.id = brought_in.item_id AND brought_in.qc_id = 0\n" 
				+ "                   LEFT JOIN sent_out ON im.id = sent_out.item_id AND sent_out.qc_id = 0\n" 
				+ "             WHERE beginning.qty IS NOT NULL OR brought_in.qty IS NOT NULL OR sent_out.qty IS NOT NULL),\n" 
				+ "        on_hold\n" 
				+ "        AS (SELECT im.id,\n" 
				+ "                   1 AS qc_id,\n" 
				+ "                     CASE WHEN beginning.qty IS NULL THEN 0 ELSE beginning.qty END\n" 
				+ "                   + CASE WHEN brought_in.qty IS NULL THEN 0 ELSE brought_in.qty END\n" 
				+ "                   - CASE WHEN sent_out.qty IS NULL THEN 0 ELSE sent_out.qty END\n" 
				+ "                      AS ending\n" 
				+ "              FROM item_master AS im\n" 
				+ "                   LEFT JOIN beginning ON im.id = beginning.item_id AND beginning.qc_id = 1\n" 
				+ "                   LEFT JOIN brought_in ON im.id = brought_in.item_id AND brought_in.qc_id = 1\n" 
				+ "                   LEFT JOIN sent_out ON im.id = sent_out.item_id AND sent_out.qc_id = 1\n" 
				+ "             WHERE beginning.qty IS NOT NULL OR brought_in.qty IS NOT NULL OR sent_out.qty IS NOT NULL),\n" 
				+ "        bad\n" 
				+ "        AS (SELECT im.id,\n" 
				+ "                   2 AS qc_id,\n" 
				+ "                     CASE WHEN beginning.qty IS NULL THEN 0 ELSE beginning.qty END\n" 
				+ "                   + CASE WHEN brought_in.qty IS NULL THEN 0 ELSE brought_in.qty END\n" 
				+ "                   - CASE WHEN sent_out.qty IS NULL THEN 0 ELSE sent_out.qty END\n" 
				+ "                      AS ending\n" 
				+ "              FROM item_master AS im\n" 
				+ "                   LEFT JOIN beginning ON im.id = beginning.item_id AND beginning.qc_id = 2\n" 
				+ "                   LEFT JOIN brought_in ON im.id = brought_in.item_id AND brought_in.qc_id = 2\n" 
				+ "                   LEFT JOIN sent_out ON im.id = sent_out.item_id AND sent_out.qc_id = 2\n" 
				+ "             WHERE beginning.qty IS NOT NULL OR brought_in.qty IS NOT NULL OR sent_out.qty IS NOT NULL),\n" 
				+ "        inventory\n" 
				+ "        AS (  SELECT row_number ()\n" 
				+ "                     OVER (\n" 
				+ "                        ORDER BY\n" 
				+ "                           CASE WHEN bad.ending IS NULL THEN 0 ELSE bad.ending END DESC,\n" 
				+ "                           CASE WHEN on_hold.ending IS NULL THEN 0 ELSE on_hold.ending END DESC,\n" 
				+ "                           CASE WHEN good.ending IS NULL THEN 0 ELSE good.ending END DESC)\n" 
				+ "                        AS line,\n" 
				+ "                     im.id,\n" 
				+ "                     im.name,\n" 
				+ "                     CASE WHEN good.ending IS NULL THEN 0 ELSE good.ending END AS good,\n" 
				+ "                     CASE WHEN on_hold.ending IS NULL THEN 0 ELSE on_hold.ending END AS on_hold,\n" 
				+ "                     CASE WHEN bad.ending IS NULL THEN 0 ELSE bad.ending END AS bad\n" 
				+ "                FROM item_master AS im\n" 
				+ "                     LEFT JOIN good ON im.id = good.id\n" 
				+ "                     LEFT JOIN on_hold ON im.id = on_hold.id\n" 
				+ "                     LEFT JOIN bad ON im.id = bad.id\n" 
				+ "               WHERE good.ending > 0 OR on_hold.ending > 0 OR bad.ending > 0\n" 
				+ "            ORDER BY CASE WHEN bad.ending IS NULL THEN 0 ELSE bad.ending END DESC,\n" 
				+ "                     CASE WHEN on_hold.ending IS NULL THEN 0 ELSE on_hold.ending END DESC,\n" 
				+ "                     CASE WHEN good.ending IS NULL THEN 0 ELSE good.ending END DESC)\n" 
				// @sql:off
				;
	}
	
	public static String addSTTperDayStmt() {
		return // @sql:on
				  "  WITH dates\n" 
				+ "     AS (SELECT current_date - 30 AS past_start,\n" 
				+ "                current_date AS past_end,\n" 
				+ "                current_date - 30 - INTERVAL '1 year' AS forecast_start,\n" 
				+ "                current_date - INTERVAL '1 year' AS forecast_end),\n" 
				+ "     sold_bundled\n" 
				+ "     AS (  SELECT ih.invoice_date AS order_date, bom.part_id AS item_id,\n" 
				+ "                  sum (id.qty * bom.qty * qp.qty) AS qty\n" 
				+ "             FROM invoice_header AS ih\n" 
				+ "                  INNER JOIN invoice_detail AS id\n" 
				+ "                     ON ih.invoice_id = id.invoice_id AND ih.series = id.series AND ih.actual > 0\n" 
				+ "                  INNER JOIN dates\n" 
				+ "                     ON ih.invoice_date BETWEEN dates.past_start\n" 
				+ "                                            AND past_end\n" 
				+ "                     OR ih.invoice_date BETWEEN dates.forecast_start\n" 
				+ "                                            AND forecast_end\n" 
				+ "                  INNER JOIN bom ON id.item_id = bom.item_id AND bom.is_free IS NOT TRUE\n" 
				+ "                  INNER JOIN qty_per AS qp\n" 
				+ "                     ON bom.uom = qp.uom AND bom.part_id = qp.item_id\n" 
				+ "         GROUP BY ih.invoice_date, bom.part_id),\n" 
				+ "     sold_as_is\n" 
				+ "     AS (  SELECT ih.invoice_date AS order_date, id.item_id, sum (id.qty * qp.qty) AS qty\n" 
				+ "             FROM invoice_header AS ih\n" 
				+ "                  INNER JOIN invoice_detail AS id\n" 
				+ "                     ON ih.invoice_id = id.invoice_id AND ih.series = id.series AND ih.actual > 0\n" 
				+ "                  INNER JOIN qty_per AS qp\n" 
				+ "                     ON id.uom = qp.uom AND id.item_id = qp.item_id\n" 
				+ "                  INNER JOIN dates\n" 
				+ "                     ON ih.invoice_date BETWEEN dates.past_start\n" 
				+ "                                            AND past_end\n" 
				+ "                     OR ih.invoice_date BETWEEN dates.forecast_start\n" 
				+ "                                            AND forecast_end\n" 
				+ "                  INNER JOIN item_master AS im\n" 
				+ "                     ON id.item_id = im.id AND im.type_id <> 2\n" 
				+ "         GROUP BY ih.invoice_date, id.item_id),\n" 
				+ "     delivered_bundled\n" 
				+ "     AS (  SELECT ih.delivery_date AS order_date, bom.part_id AS item_id,\n" 
				+ "                  sum (id.qty * bom.qty * qp.qty) AS qty\n" 
				+ "             FROM delivery_header AS ih\n" 
				+ "                  INNER JOIN delivery_detail AS id\n" 
				+ "                     ON ih.delivery_id = id.delivery_id AND ih.actual > 0\n" 
				+ "                  INNER JOIN dates\n" 
				+ "                     ON ih.delivery_date BETWEEN dates.past_start\n" 
				+ "                                            AND past_end\n" 
				+ "                     OR ih.delivery_date BETWEEN dates.forecast_start\n" 
				+ "                                            AND forecast_end\n" 
				+ "                  INNER JOIN bom ON id.item_id = bom.item_id AND bom.is_free IS NOT TRUE\n" 
				+ "                  INNER JOIN qty_per AS qp\n" 
				+ "                     ON bom.uom = qp.uom AND bom.part_id = qp.item_id\n" 
				+ "         GROUP BY ih.delivery_date, bom.part_id),\n" 
				+ "     delivered_as_is\n" 
				+ "     AS (  SELECT ih.delivery_date AS order_date, id.item_id, sum (id.qty * qp.qty) AS qty\n" 
				+ "             FROM delivery_header AS ih\n" 
				+ "                  INNER JOIN delivery_detail AS id\n" 
				+ "                     ON ih.delivery_id = id.delivery_id AND ih.actual > 0\n" 
				+ "                  INNER JOIN qty_per AS qp\n" 
				+ "                     ON id.uom = qp.uom AND id.item_id = qp.item_id\n" 
				+ "                  INNER JOIN dates\n" 
				+ "                     ON ih.delivery_date BETWEEN dates.past_start\n" 
				+ "                                            AND past_end\n" 
				+ "                     OR ih.delivery_date BETWEEN dates.forecast_start\n" 
				+ "                                            AND forecast_end\n" 
				+ "                  INNER JOIN item_master AS im\n" 
				+ "                     ON id.item_id = im.id AND im.type_id <> 2\n" 
				+ "         GROUP BY ih.delivery_date, id.item_id),\n" 
				+ "     combined\n" 
				+ "     AS (SELECT * FROM sold_bundled\n" 
				+ "         UNION\n" 
				+ "         SELECT * FROM sold_as_is\n" 
				+ "         UNION\n" 
				+ "         SELECT * FROM delivered_bundled\n" 
				+ "         UNION\n" 
				+ "         SELECT * FROM delivered_as_is),\n" 
				+ "     selling_day\n" 
				+ "     AS (  SELECT count(DISTINCT order_date) AS selling_days\n" 
				+ "             FROM combined),\n" 
				+ "     stt_per_day AS (\n" 
				+ "     SELECT item_id AS id, sum(qty) / selling_days AS qty\n" 
				+ "             FROM combined, selling_day\n" 
				+ "         GROUP BY item_id, selling_days\n" 
				+ "     ORDER BY item_id)\n" 
				// @sql:off
				;
		
	}

	public static String addLatestPriceStmt(boolean isWithCutoffDate) {
		String cutoffDate = "";
		if (isWithCutoffDate)
			cutoffDate = "" 
				// @sql:on
		        + "INNER JOIN parameter AS pm\n" 
				+ "   ON price.start_date <= pm.start_date\n";
		return    "price_cutoff_date\n"
				+ "AS (SELECT price.item_id AS cutoff_item_id,\n"
				+ "           max(price.start_date) AS cutoff_date\n"
				+ "      FROM price\n"
				+ cutoffDate
				+ "     WHERE tier_id = 1\n"
				+ "  GROUP BY item_id\n),\n"
				+ "latest_price\n"
				+ "AS (SELECT item_id,\n"
				+ "           price\n"
				+ "      FROM price\n"
				+ "	          INNER JOIN price_cutoff_date AS cutoff\n"
				+ "              ON     price.start_date = cutoff_date\n"
				+ "				    AND price.item_id = cutoff_item_id\n"
				+ "     WHERE tier_id = 1)\n";
				// @sql:off
	}
}
